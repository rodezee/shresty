user                root    root;
#worker_processes 1;


env ENTRYPOINT;
env COMMAND;
env COOKIE_SECRET;


# Enables the use of JIT for regular expressions to speed-up their processing.
pcre_jit on;


#error_log  logs/error.log;
#error_log  logs/error.log  notice;
#error_log  logs/error.log  info;

#pid        logs/nginx.pid;

events {
    worker_connections  1024;
}

http {
    include       mime.types;
    default_type  application/octet-stream;

    # See Move default writable paths to a dedicated directory (#119)
    # https://github.com/openresty/docker-openresty/issues/119
    client_body_temp_path /var/run/openresty/nginx-client-body;
    proxy_temp_path       /var/run/openresty/nginx-proxy;
    fastcgi_temp_path     /var/run/openresty/nginx-fastcgi;
    uwsgi_temp_path       /var/run/openresty/nginx-uwsgi;
    scgi_temp_path        /var/run/openresty/nginx-scgi;

    sendfile        on;
    #tcp_nopush     on;

    #keepalive_timeout  0;
    keepalive_timeout  65;

    #gzip  on;

    #include /etc/nginx/conf.d/*.conf;

    error_log stderr notice;
    variables_hash_max_size 1024;
    access_log off;
    real_ip_header X-Real-IP;
    charset utf-8;
    lua_package_path "/app/?.lua;;";

    init_by_lua_block {
        require "resty.session".init({
            remember = true,
            audience = "shresty",
            secret   = os.getenv("COOKIE_SECRET"),
            storage  = "cookie",
        })
    }

    server {
        listen 1080;
        lua_code_cache 'off'; # turn 'on' for production
        resolver 127.0.0.11 valid=10s; #Set the Docker DNS
        add_header Access-Control-Allow-Origin *; #enable CORS to do requests from other domains
        default_type text/html;
        root /app/www;
        index index.sh index.html index.htm;

        location / {
            try_files $uri $uri/ =404;
        }

        # location ~ \.sh$ {
        #     fastcgi_pass unix:/tmp/exec.sock;
        # }

        location ~ \.sh$ {
            # gzip off;
            # root /app/www;
            # autoindex on;
            
            # fastcgi_pass unix:/var/run/fcgiwrap.socket;

            fastcgi_param  QUERY_STRING       $query_string;
            fastcgi_param  REQUEST_METHOD     $request_method;
            fastcgi_param  CONTENT_TYPE       $content_type;
            fastcgi_param  CONTENT_LENGTH     $content_length;
            fastcgi_param  SCRIPT_NAME        $fastcgi_script_name;
            fastcgi_param  REQUEST_URI        $request_uri;
            fastcgi_param  DOCUMENT_URI       $document_uri;
            fastcgi_param  SERVER_PROTOCOL    $server_protocol;
            fastcgi_param  REQUEST_SCHEME     $scheme;
            fastcgi_param  HTTPS              $https if_not_empty;
            fastcgi_param  GATEWAY_INTERFACE  CGI/1.1;
            fastcgi_param  SERVER_SOFTWARE    nginx/$nginx_version;
            fastcgi_param  REMOTE_ADDR        $remote_addr;
            fastcgi_param  REMOTE_PORT        $remote_port;
            fastcgi_param  SERVER_ADDR        $server_addr;
            fastcgi_param  SERVER_PORT        $server_port;
            fastcgi_param  SERVER_NAME        $server_name;
            fastcgi_param  REDIRECT_STATUS    200;

            fastcgi_param DOCUMENT_ROOT /app/www;
            fastcgi_param SCRIPT_FILENAME /app/www/$fastcgi_script_name;

            content_by_lua_block {
                local session, session_err = require "resty.session".start()
                if session_err then session = require "resty.session".new() end
                local sid = session.get_property("id")
                io.stdout:setvbuf 'no'
                local handle = io.popen("/app/www"..ngx.var.document_uri, "r")
                if handle == "" or handle == nil then
                    ngx.say("Empty, session_id: "..sid)
                    ngx.status = 404
                    return
                end
                handle:flush()
                local result = handle:read("*all")
                handle:close()
                ngx.print(result)
                ngx.say("session_id: "..sid)
            }
        }

        location = /examples/ {
            autoindex on;
            autoindex_exact_size off;
            autoindex_format html;
            autoindex_localtime on;
        }

        location = /GET {
            content_by_lua_block {
                local args, err = ngx.req.get_uri_args()

                if err == "truncated" then
                    -- one can choose to ignore or reject the current request here
                    ngx.say("get truncated")
                end

                for key, val in pairs(args) do
                    if type(val) == "table" then
                        ngx.say(key, ": ", table.concat(val, ", "))
                    else
                        ngx.say(key, ": ", val)
                    end
                end
            }
        }

        location = /POST {
            content_by_lua_block {
                ngx.req.read_body()
                local args, err = ngx.req.get_post_args()

                if err == "truncated" then
                    -- one can choose to ignore or reject the current request here
                    ngx.say("POST truncated")
                end

                if not args then
                    ngx.say("failed to get post args: ", err)
                    return
                end
                for key, val in pairs(args) do
                    if type(val) == "table" then
                        ngx.say(key, ": ", table.concat(val, ", "))
                    else
                        ngx.say(key, ": ", val)
                    end
                end
            }
        }

        location /exec {
            add_header Content-Type 'application/json';
            content_by_lua_block {
                 require 'shresty'.exec(
                    ngx.var.uri:sub(7),
                    ngx.req.get_headers()['Request-User'],
                    ngx.req.get_headers()['Request-Password'],
                    ngx.req.get_headers()['Authorization'],
                    os.getenv("ENTRYPOINT"),
                    os.getenv("COMMAND"),
                    true
                )
            }
        }

        location /start {
            content_by_lua_block {
                local session = require "resty.session".new()
                session:set_subject("OpenResty Fan")
                session:set("quote", "The quick brown fox jumps over the lazy dog")
                local ok, err = session:save()
            
                ngx.say(string.format([[
                    <html>
                    <body>
                        <p>Session started (%s)</p>
                        <p><a href=/started>Check if it really was</a></p>
                    </body>
                    </html>
                ]], err or "no error"))
            }
        }

        location /started {
            content_by_lua_block {
                local session, err = require "resty.session".start()
                ngx.say(string.format([[
                    <html>
                    <body>
                        <p>Session was started by %s (%s)</p>
                        <p><blockquote>%s</blockquote></p>
                        <p><a href=/modify>Modify the session</a></p>
                    </body>
                    </html>
                ]],
                session:get_subject() or "Anonymous",
                err or "no error",
                session:get("quote") or "no quote"
                ))
            }
        }
        
        location /modify {
            content_by_lua_block {
                local session, err = require "resty.session".start()
                session:set_subject("Lua Fan")
                session:set("quote", "Lorem ipsum dolor sit amet")
                local _, err_save = session:save()
                ngx.say(string.format([[
                    <html>
                    <body>
                        <p>Session was modified (%s)</p>
                        <p><a href=/modified>Check if it is modified</a></p>
                    </body>
                    </html>
                ]], err or err_save or "no error"))
            }
        }
        
        location /modified {
            content_by_lua_block {
                local session, err = require "resty.session".start()
                ngx.say(string.format([[
                    <html>
                    <body>
                        <p>Session was started by %s (%s)</p>
                        <p><blockquote>%s</blockquote></p>
                        <p><a href=/destroy>Destroy the session</a></p>
                    </body>
                    </html>
                ]],
                session:get_subject() or "Anonymous",
                err or "no error",
                session:get("quote")  or "no quote"
                ))
            }
        }
        
        location /destroy {
            content_by_lua_block {
                local ok, err = require "resty.session".destroy()
                ngx.say(string.format([[
                    <html>
                    <body>
                        <p>Session was destroyed (%s)</p>
                        <p><a href=/destroyed>Check that it really was?</a></p>
                    </body>
                    </html>
                ]], err or "no error"))
            }
        }
        
        location /destroyed {
            content_by_lua_block {
                local session, err = require "resty.session".open()
                ngx.say(string.format([[
                    <html>
                    <body>
                        <p>Session was really destroyed, you are known as %s (%s)</p>
                        <p><a href=/start>Start again</a></p>
                    </body>
                    </html>
                ]],
                session:get_subject() or "Anonymous",
                err or "no error"
                ))
            }
        }

        location /headers-dump {
            default_type text/plain;
            content_by_lua_block {
                local h = ngx.req.get_headers()
                for k, v in pairs(h) do
                    ngx.say(string.format("%s: %s", k ,v))
                end
            }
        }
    }

    # Don't reveal OpenResty version to clients.
    server_tokens off;
}
